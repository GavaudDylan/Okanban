# JOUR 4 - API - REST & CRUD (partie 2)

## Menu du jour

```
=== Matin COURS ===

- Correction & bonnes pratiques d'API
  - Validations des entrées 
    - ✅ "Vanilla" validation
    - ✅ (bonus) Joi, Zod...
  - Gestion des erreurs 
    - ✅ 4XX vs 5XX
    - ✅ (bonus) Factorisation de la gestion d'erreur (controllerWrapper)
  - Testing HTTP
    - ✅ Insomnia, Postman, Thunder Client...

- Des bonus à foisons
  - (bonus) Versionner une API (préfix /api et/ou /v1)
  - ❌ (bonus) Multi-router
  - ❌ (bonus) Documentation Swagger

=== Aprem ATELIER ===

- API REST : /cards endpoints
  - GET /cards
  - GET /cards/:id
  - POST /cards
  - PATCH /cards/:id
  - DELETE /cards

- API REST : /tags endpoints
  - GET /tags
  - GET /tags/:id
  - POST /tags
  - PATCH /tags/:id
  - DELETE /tags
  - PUT /cards/:cardId/tags/:tagId
  - DELETE /cards/:cardId/tags/:tagId

```


## Client HTTP

- `Chrome` (que du `GET` via la barre d'URL) 
- `cURL`
- `fetch` (JS)
- `Insomnia`
- `Postman`
- `Thunder Client` (Extension VScode)


## Falsy values

En JS, toutes les valeurs ont un équivalent `true` (truthy) / `false` (falsy).

Tout le monde est truthy sauf 6 valeurs : 
- `false`
- `null`
- `undefined`
- `""`
- `0`
- `NaN`

### Exemple

```js
false || true   // true

false || 1      // 1

undefined || 1  // 1
```

## La règle d'or de la création d'API

**Never trust user input** 
- => contrôler les inputs utilisteurs (body, query params, etc...)
  - pour éviter les injections SQL
  - pour répondre convenablement au client s'il fait des bétises
  - => pour avoir une API sécurisé et facile à utiliser !


## Gestion d'erreur approfondie 

(bonus) : https://github.com/enzoclock/express-error-handling


## Include sequelize

```js
// Equivalence entre les includes : 
ModelA.findAll({
  include: "modelB",
  include: { association: "modelB" },
  include: ["modelB"]
})
```


```js
ModelA.findAll({
  include: "modelB",

  include: { association: "modelB", include: "modelC" }, // Avantage

  include: ["modelB", "modelD"] // Avantage
});
```


## API : No Breaking Changes

Une API c'est une interface que un client va requêter.

Si du jour au lendemain, les devs de l'API change ce que celle-ci renvoie ==> on casse tous les systèmes qui requête cette API

Exemple de **breaking change** : 
- changement du nom d'un champ
- suppression d'un champ
- suppression d'une route

Notes : certaines modifications ne sont pas problématiques : 
- ajouter un champ => OK !
- rajouter une route => OK !

Si on veut vraiment changer toute l'API, ce qui est généralement fait est plutôt d'ajouter une nouvelle version !
- /api
- /api/v2/...

Proposition : 
- préfixons notre api par `/api` pour voir comment on peut faire ça.
